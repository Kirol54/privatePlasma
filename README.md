# Plasma Shielded Pool

Private USDT payments on Plasma using SP1 zero-knowledge proofs.

Users deposit USDT into a shielded pool and receive a cryptographic note commitment. Transfers happen privately — the ZK proof guarantees correctness without revealing sender, recipient, or amount. Users can withdraw back to any address at any time.

## Architecture

```
contracts/            Solidity — on-chain state + verification
  ShieldedPool.sol      Main contract: deposit, transfer, withdraw
  MerkleTree.sol        Incremental keccak256 Merkle tree (30-root history)
  interfaces/           ISP1Verifier, IERC20
test/                 Solidity tests (Foundry)
deploy/               Foundry deployment script

lib/                  Rust (no_std) — shared types + crypto primitives
programs/
  transfer/           SP1 guest — 2-in-2-out private transfer circuit
  withdraw/           SP1 guest — withdrawal circuit
script/               Rust host — proof generation CLI
client/               TypeScript SDK — wallet, Merkle tree, prover, pool client
tests/                Rust integration tests

Makefile              Build, test, deploy targets (run `make help`)
.env.example          Deployment configuration template
```

## How It Works

### Three Operations

**Deposit** — Public. User approves USDT, calls `deposit(commitment, amount)`. The commitment is inserted into the on-chain Merkle tree. No ZK proof needed.

**Private Transfer** — A ZK proof shows:
- Two input notes exist in the Merkle tree (via Merkle proofs)
- The sender owns both inputs (knows the spending keys)
- Two output notes are created with the same total value (conservation)
- Nullifiers prevent double-spending

The contract sees only nullifiers and output commitments — no amounts, no addresses.

**Withdraw** — A ZK proof shows:
- The input note exists in the tree and the sender owns it
- The withdrawal amount + change = input amount
- The recipient address is committed inside the proof (prevents front-running)

### Cryptography

All hashing uses **keccak256** (matching Solidity). Note commitments, nullifiers, public key derivation, and the Merkle tree all use keccak256.

| Primitive | Formula |
|-----------|---------|
| Commitment | `keccak256(amount_be_8 \|\| pubkey_32 \|\| blinding_32)` |
| Nullifier | `keccak256(commitment \|\| spending_key)` |
| Public Key | `keccak256(spending_key)` |
| Merkle Hash | `keccak256(left \|\| right)` |

Note encryption uses NaCl box (x25519 + XSalsa20-Poly1305) for selective disclosure to recipients.

### ZK Circuits (SP1)

Both circuits compile to RISC-V and run inside the SP1 zkVM. Proofs are Groth16 for on-chain verification (~260 bytes per proof).

| Circuit | Inputs | Outputs | Public Values | Cycles |
|---------|--------|---------|---------------|--------|
| Transfer | 2 notes in | 2 notes out | root, 2 nullifiers, 2 commitments (160 bytes) | ~321K |
| Withdraw | 1 note in | withdrawal + optional change | root, nullifier, recipient, amount, change commitment (160 bytes) | ~169K |

## Prerequisites

- **Rust** (stable)
- **SP1 toolchain**: `curl -L https://sp1.succinct.xyz | bash && sp1up`
- **Foundry**: `curl -L https://foundry.paradigm.xyz | bash && foundryup`
- **Node.js** >= 18

## Quick Start

```bash
# 1. Build everything (SP1 circuits, host, contracts, TS SDK)
make build-all

# 2. Run all tests
make test-all

# 3. Execute circuits (no proof, fast verification)
make execute-transfer
make execute-withdraw

# 4. Print verification keys (for contract deployment)
make vkeys

# 5. Generate real Groth16 proofs (via Succinct Prover Network)
make prove-transfer INPUT=input.json OUTPUT=proof.json
```

The test JSON input files (`fixtures/test_transfer_input.json`, `fixtures/test_withdraw_input.json`) are generated by `make test-integration`.

Run `make help` to see all available targets.

## TypeScript SDK

```typescript
import {
  ShieldedPoolClient,
  ShieldedWallet,
  Prover,
} from "@shielded-pool/client";
import { ethers } from "ethers";

// Create a wallet from a 32-byte spending key
const wallet = new ShieldedWallet(spendingKey);

// Connect to the pool
const client = new ShieldedPoolClient({
  poolAddress: "0x...",
  tokenAddress: "0x...", // USDT on Plasma
  signer: ethers.Wallet.fromPhrase("...").connect(provider),
});

// Deposit 100 USDT into the shielded pool
await client.deposit(100_000000n); // 6 decimals

// Private transfer to another user
await client.privateTransfer(
  recipientPubkey, // 32 bytes
  50_000000n,
);

// Withdraw to a public address
await client.withdraw(
  "0xRecipientAddress",
  50_000000n,
);

// Scan for incoming notes (requires viewing key)
await client.sync();
console.log("Balance:", wallet.getBalance());
```

### SDK Modules

| Module | Description |
|--------|-------------|
| `crypto.ts` | keccak256, commitments, nullifiers, key derivation |
| `merkle.ts` | Client-side Merkle tree (mirrors MerkleTree.sol) |
| `wallet.ts` | Spending key management, note tracking, coin selection |
| `encryption.ts` | NaCl box encryption for note data |
| `prover.ts` | Wraps the Rust proof generation binary |
| `pool.ts` | High-level `ShieldedPoolClient` for deposit/transfer/withdraw |

## Project Dependencies

### Rust

| Crate | Version | Purpose |
|-------|---------|---------|
| `sp1-sdk` | 4.1.7 | SP1 prover host SDK |
| `sp1-zkvm` | 4.1.7 | SP1 guest VM (RISC-V) |
| `tiny-keccak` | 2.0 | Keccak256 (no_std) |
| `serde` | =1.0.217 | Serialization (pinned for compatibility) |
| `clap` | 4 | CLI argument parsing |

### TypeScript

| Package | Purpose |
|---------|---------|
| `ethers` ^6.13 | Contract interaction, keccak256 |
| `tweetnacl` ^1.0 | NaCl box encryption |

## Proof JSON Format

The prover outputs a JSON file with three fields:

```json
{
  "proof": "hex-encoded Groth16 proof bytes",
  "public_values": "hex-encoded ABI-encoded public values",
  "vkey": "bytes32 verification key hash"
}
```

Pass `proof` and `public_values` directly to the Solidity contract's `privateTransfer()` or `withdraw()` functions.

## Deployment

All deployment is driven by the `Makefile` and a `.env` file.

### 1. Configure environment

```bash
cp .env.example .env
# Edit .env — fill in TOKEN_ADDRESS, VERIFIER_ADDRESS, and PRIVATE_KEY
```

### 2. Generate verification keys

```bash
make vkeys
# Prints TRANSFER_VKEY and WITHDRAW_VKEY — paste into .env
```

### 3. Deploy to local Anvil

```bash
# Terminal 1: start Anvil
make anvil

# Terminal 2: deploy
make deploy-local
```

### 4. Deploy to Plasma

```bash
# Set RPC_URL in .env to the Plasma RPC endpoint, then:
make deploy-plasma
```

The deploy script prints the deployed `ShieldedPool` address. Use it to configure the TypeScript SDK.

### All Makefile targets

```bash
make help
```

## Documentation

- **[Frontend Integration Guide](docs/frontend-integration.md)** — How to build a user-facing app on top of the SDK. Covers wallet connection, spending key derivation, deposit/transfer/withdraw UI flows, proof generation via the Succinct Prover Network, and a minimal React example.
- **[How It Works (Non-Technical)](docs/how-it-works.md)** — Plain-language explanation for non-developers. What the project does, why privacy matters, how the sealed-envelope analogy works, use cases, and FAQ.

## License

MIT
