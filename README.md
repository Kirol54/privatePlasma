# Plasma Shielded Pool

Private USDT payments on Plasma using SP1 zero-knowledge proofs.

Users deposit USDT into a shielded pool and receive a cryptographic note commitment. Transfers happen privately — the ZK proof guarantees correctness without revealing sender, recipient, or amount. Users can withdraw back to any address at any time.

## Architecture

```
contracts/            Solidity — on-chain state + verification
  ShieldedPool.sol      Main contract: deposit, transfer, withdraw
  MerkleTree.sol        Incremental keccak256 Merkle tree (30-root history)
  interfaces/           ISP1Verifier, IERC20
test/                 Solidity tests (Foundry)
deploy/               Foundry deployment script

lib/                  Rust (no_std) — shared types + crypto primitives
programs/
  transfer/           SP1 guest — 2-in-2-out private transfer circuit
  withdraw/           SP1 guest — withdrawal circuit
script/               Rust host — proof generation CLI + e2e test
client/               TypeScript SDK — wallet, Merkle tree, prover, pool client
frontend/             React app — browser UI (Vite + React 18 + TypeScript)
proxy/                Express server — bridges browser to Rust prover
tests/                Rust integration tests

Makefile              Build, test, deploy targets (run `make help`)
.env.example          Deployment configuration template
```

## How It Works

### Three Operations

**Deposit** — Public. User approves USDT, calls `deposit(commitment, amount, encryptedData)`. The commitment is inserted into the on-chain Merkle tree. The encrypted note data allows the depositor to recover the note via scanning. No ZK proof needed.

**Private Transfer** — A ZK proof shows:

- Two input notes exist in the Merkle tree (via Merkle proofs)
- The sender owns both inputs (knows the spending keys)
- Two output notes are created with the same total value (conservation)
- Nullifiers prevent double-spending

The contract sees only nullifiers and output commitments — no amounts, no addresses. Each output note is encrypted with the recipient's **viewing public key** and emitted as an `EncryptedNote` event, allowing the recipient to detect incoming transfers by scanning the chain.

**Withdraw** — A ZK proof shows:

- The input note exists in the tree and the sender owns it
- The withdrawal amount + change = input amount
- The recipient address is committed inside the proof (prevents front-running)

Any change note is encrypted for the withdrawer's viewing key.

### Cryptography

All hashing uses **keccak256** (matching Solidity). Note commitments, nullifiers, public key derivation, and the Merkle tree all use keccak256.

| Primitive   | Formula                                                  |
| ----------- | -------------------------------------------------------- |
| Commitment  | `keccak256(amount_be_8 \|\| pubkey_32 \|\| blinding_32)` |
| Nullifier   | `keccak256(commitment \|\| spending_key)`                |
| Public Key  | `keccak256(spending_key)`                                |
| Merkle Hash | `keccak256(left \|\| right)`                             |

Note encryption uses NaCl box (x25519 + XSalsa20-Poly1305) for selective disclosure to recipients.

### ZK Circuits (SP1)

Both circuits compile to RISC-V and run inside the SP1 zkVM. Proofs are Groth16 for on-chain verification (~260 bytes per proof).

| Circuit  | Inputs     | Outputs                      | Public Values                                                     | Cycles |
| -------- | ---------- | ---------------------------- | ----------------------------------------------------------------- | ------ |
| Transfer | 2 notes in | 2 notes out                  | root, 2 nullifiers, 2 commitments (160 bytes)                     | ~321K  |
| Withdraw | 1 note in  | withdrawal + optional change | root, nullifier, recipient, amount, change commitment (160 bytes) | ~169K  |

## Prerequisites

- **Rust** (stable)
- **SP1 toolchain**: `curl -L https://sp1.succinct.xyz | bash && sp1up --version 5.2.4`
- **Foundry**: `curl -L https://foundry.paradigm.xyz | bash && foundryup`
- **Node.js** >= 18

## Quick Start

```bash
# 1. Build everything (SP1 circuits, host, contracts, TS SDK)
make build-all

# 2. Run all tests
make test-all

# 3. Execute circuits (no proof, fast verification)
make execute-transfer
make execute-withdraw

# 4. Print verification keys (for contract deployment)
make vkeys

# 5. Generate real Groth16 proofs (via Succinct Prover Network)
make prove-transfer INPUT=input.json OUTPUT=proof.json
```

The test JSON input files (`fixtures/test_transfer_input.json`, `fixtures/test_withdraw_input.json`) are generated by `make test-integration`.

Run `make help` to see all available targets.

## Frontend App

A React + TypeScript frontend with a dark green theme, providing a complete UI for the shielded pool:

```bash
# Start the proxy (bridges browser to Rust SP1 prover)
cd proxy && npm install && SP1_PROVER=network NETWORK_PRIVATE_KEY=? npm start

# Start the frontend
cd frontend && npm install && npm run dev
```

### Features

- **MetaMask integration** — connect any Ethereum wallet
- **Deposit** — convert public USDT to shielded notes
- **Private Transfer** — send to any recipient using their shielded + viewing public keys (2-in-2-out circuit, requires 2+ notes)
- **Withdraw** — convert shielded notes back to public USDT
- **Note scanning** — automatically detects incoming transfers via `EncryptedNote` events
- **Wallet import/export** — export wallet to JSON file, import from file or spending key
- **Key sharing** — dashboard displays both shielded pubkey and viewing pubkey (click to copy)

### Two Keys for Receiving

To receive a private transfer, share **both** keys with the sender:

1. **Shielded Public Key** — used in the ZK proof to create a note owned by you
2. **Viewing Public Key** — used to encrypt the note so you can detect it via scanning

Both keys are displayed on the Dashboard and can be copied with a click.

## TypeScript SDK

```typescript
import {
	ShieldedPoolClient,
	ShieldedWallet,
	Prover,
} from "@shielded-pool/client";
import { ethers } from "ethers";

// Create a wallet from a 32-byte spending key
const wallet = new ShieldedWallet(spendingKey);

// Connect to the pool
const client = new ShieldedPoolClient({
	poolAddress: "0x...",
	tokenAddress: "0x...", // USDT on Plasma
	signer: ethers.Wallet.fromPhrase("...").connect(provider),
});

// Deposit 100 USDT into the shielded pool
await client.deposit(100_000000n); // 6 decimals

// Private transfer to another user (requires recipient's viewing pubkey for note encryption)
await client.privateTransfer(
	recipientPubkey, // 32 bytes — shielded public key
	50_000000n,
	recipientViewingPubkey, // 32 bytes — for encrypting the note
);

// Withdraw to a public address
await client.withdraw("0xRecipientAddress", 50_000000n);

// Scan for incoming notes (decrypts EncryptedNote events with viewing key)
await client.sync();
console.log("Balance:", wallet.getBalance());
```

### SDK Modules

| Module          | Description                                                   |
| --------------- | ------------------------------------------------------------- |
| `crypto.ts`     | keccak256, commitments, nullifiers, key derivation            |
| `merkle.ts`     | Client-side Merkle tree (mirrors MerkleTree.sol)              |
| `wallet.ts`     | Spending key management, note tracking, coin selection        |
| `encryption.ts` | NaCl box encryption/decryption for note data + viewing keys   |
| `prover.ts`     | Wraps the Rust proof generation binary                        |
| `pool.ts`       | High-level `ShieldedPoolClient` for deposit/transfer/withdraw |

## Project Dependencies

### Rust

| Crate         | Version | Purpose                                       |
| ------------- | ------- | --------------------------------------------- |
| `sp1-sdk`     | 5.2.4   | SP1 prover host SDK                           |
| `sp1-zkvm`    | 5.2.4   | SP1 guest VM (RISC-V)                         |
| `tiny-keccak` | 2.0     | Keccak256 (no_std)                            |
| `serde`       | 1.0     | Serialization                                 |
| `alloy`       | 1.4     | Ethereum provider, signers, contract bindings |
| `clap`        | 4       | CLI argument parsing                          |

### TypeScript

| Package          | Purpose                         |
| ---------------- | ------------------------------- |
| `ethers` ^6.13   | Contract interaction, keccak256 |
| `tweetnacl` ^1.0 | NaCl box encryption             |

## Proof JSON Format

The prover outputs a JSON file with three fields:

```json
{
	"proof": "hex-encoded Groth16 proof bytes",
	"public_values": "hex-encoded ABI-encoded public values",
	"vkey": "bytes32 verification key hash"
}
```

Pass `proof` and `public_values` directly to the Solidity contract's `privateTransfer()` or `withdraw()` functions.

## Deployment

All deployment is driven by the `Makefile` and a `.env` file.

### 1. Configure environment

```bash
cp .env.example .env
# Edit .env — fill in TOKEN_ADDRESS, VERIFIER_ADDRESS, and PRIVATE_KEY
```

### 2. Generate verification keys

```bash
make vkeys
# Prints TRANSFER_VKEY and WITHDRAW_VKEY — paste into .env
```

### 3. Deploy to local Anvil

```bash
# Terminal 1: start Anvil
make anvil

# Terminal 2: deploy
make deploy-local
```

### 4. Deploy to Plasma

```bash
# Set RPC_URL in .env to the Plasma RPC endpoint, then:
make deploy-plasma
```

The deploy script prints the deployed `ShieldedPool` address. Save it to `POOL_ADDRESS` in your `.env`.

### All Makefile targets

```bash
make help
```

## End-to-End Test

Run the full deposit → private transfer → withdraw lifecycle against a deployed contract with real Groth16 proofs:

```bash
# 1. Ensure .env has POOL_ADDRESS, PRIVATE_KEY, NETWORK_PRIVATE_KEY, etc.
# 2. Run the E2E flow:
make e2e
```

This generates two real ZK proofs via the Succinct Prover Network (~2-5 min each), submits them on-chain with encrypted note data, and verifies final state (nullifiers, Merkle root, balances). Notes are encrypted using NaCl box so they can be detected by the recipient's frontend via `EncryptedNote` event scanning.

### Configurable amounts

Set these in `.env` to customise the test flow (defaults shown):

| Variable                   | Default     | Description                                                        |
| -------------------------- | ----------- | ------------------------------------------------------------------ |
| `DEPOSIT_A`                | `0.7`       | First deposit (USDT)                                               |
| `DEPOSIT_B`                | `0.3`       | Second deposit (USDT)                                              |
| `TRANSFER_AMOUNT`          | `0.5`       | Private transfer to recipient                                      |
| `WITHDRAW_AMOUNT`          | `0.3`       | Recipient withdrawal                                               |
| `RECIPIENT_PUBKEY`         | _(random)_  | 32-byte hex spending key for recipient                             |
| `RECIPIENT_VIEWING_PUBKEY` | _(derived)_ | 32-byte hex viewing public key (if not set, derived from spending) |

See **[E2E Test Guide](docs/e2e-test.md)** for the full step-by-step breakdown, example output, and troubleshooting.

## Proving Architecture & Trust Model

### Why the Express proxy exists

The React frontend cannot run Rust or `cargo` directly in the browser. The Express proxy (`proxy/`) bridges this gap: it receives proof requests from the browser and invokes the SP1 SDK (Rust) as a subprocess. This architecture was chosen for speed and familiarity during the hackathon — **it is not a protocol requirement**. The proxy is an implementation convenience, not a fundamental part of the design.

### Local-first recommended usage

The entire system can be run **locally via CLI** without the frontend, proxy, or any remote prover:

```bash
# Execute circuits locally on CPU (no proof generation, fast verification)
make execute-transfer
make execute-withdraw

# Run the full deposit → transfer → withdraw lifecycle with real proofs
# Set SP1_PROVER=cpu to prove locally instead of using the Succinct Network
SP1_PROVER=cpu make e2e
```

In this mode, all private inputs (spending keys, note data, amounts) stay entirely on the user's machine. **This is the recommended setup for maximum privacy today.**

### Direct client → prover (future)

In principle, browsers could submit proof requests directly to the Succinct Prover Network (or any compatible prover service), removing the proxy entirely. This was not implemented due to hackathon time constraints and the need to replicate SP1 SDK request-building logic in-browser. It remains a viable future improvement.

### Trust assumptions

| Mode | What you trust | Privacy |
|------|---------------|---------|
| **Local CPU proving** (`SP1_PROVER=cpu`) | Only the local machine | Maximum — all inputs stay local |
| **Direct client → prover** (future) | The prover service only | Prover sees raw inputs during proving |
| **Frontend + proxy** (current demo) | The proxy server + the prover service | Proxy and prover both see raw inputs |

In all modes, the resulting ZK proof reveals nothing about private inputs. Trust differences only affect who sees inputs *during* proof generation.

### Enterprise / production options

- **TEE-backed SP1 proving** — The Succinct Prover Network supports Trusted Execution Environment (TEE) enclaves, reducing data exposure when using remote provers. Inputs are processed inside the enclave and not visible to the prover operator.
- **On-prem enterprise deployments** — Organizations can run their own GPU provers on internal infrastructure. Whitelisted on-prem provers ensure that private inputs never leave the corporate network.

These options allow enterprises to use remote proving without exposing confidential transaction data to third parties.

---

## Documentation

- **[E2E Test Guide](docs/e2e-test.md)** — Full walkthrough of the end-to-end test script. Configuration (including recipient viewing keys), example output, Merkle tree mirroring, proof generation, and troubleshooting.
- **[Frontend Integration Guide](docs/frontend-integration.md)** — How to build a user-facing app on top of the SDK. Covers wallet connection, viewing keys, note encryption/scanning, deposit/transfer/withdraw UI flows, wallet import/export, and a minimal React example.
- **[How It Works (Non-Technical)](docs/how-it-works.md)** — Plain-language explanation for non-developers. What the project does, why privacy matters, how the sealed-envelope analogy works, use cases, and FAQ.

## License

MIT
